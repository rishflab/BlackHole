#version 450
//#extension GL_EXT_shader_16bit_storage

#define EPSILON 0.0001
#define M_PI 3.14159265359

//layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba8) uniform writeonly image2D img;

layout(set = 1,  binding = 0) buffer Camera {
    mat4 view;
    mat4 model;
};

layout(set = 2, binding = 0) buffer Indices {
    uint indices[];
};

layout(set = 3, binding = 0) buffer Vertices {
    float vertices[];
};


struct Sphere {
    vec3 centre;
    float radius;
};

struct Light {
    vec3 position;
    float intensity;
};

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct Triangle {
    vec3 v0;
    vec3 v1;
    vec3 v2;
};

float mollerTrumboreIntersectTriangle(vec3 orig, vec3 dir, vec3 v0, vec3 v1, vec3 v2){

    // adapted from Moller-Trumbore intersection algorithm pseudocode on wikipedia
    vec3 e1, e2; // Edge1, Edge2
    vec3 P, Q, T;
    float det, inv_det, u, v;
    float t;

    // vectors for edges sharing V1
    e1 = v1 - v0;
    e2 = v2 - v0;

    // begin calculating determinant - also used to calculate u param
    s1 = cross(dir, e2);
    //P = normalize(P);
    // if determinant is near zero, ray lies in plane of triangle
    det = dot(e1, s1);
    // NOT culling
    if (det < -EPSILON ){
        return -1.0;
    }
    invd = 1.0 / det;

    // calculate distance from v0 to ray origin
    d = orig - v0;

    // calculate u parameter and test bound
    u = dot(d, s1) * invd;
    // the intersection lies outside of the triangle
    if (u < 0.0 || u > 1.0){
        return -1.0;
    }

    // prepare to test v parameter
    s2 = cross(d, e1);

    // calculate v param and test bound
    v = dot(dir, s2) * invd;

    // the intersection is outside the triangle?
    if (v < 0.0 || (u + v) > 1.0){
        return -1.0;
    }

    t = dot(e2, s2) * invd;

    if (t > 0.0) {
        return t;
    }

    return -1.0;
}


void model_world_transform(mat4 transform, inout vec3 v0, inout vec3 v1, inout vec3 v2){

    v0 = (transform * vec4(v0, 1.0)).xyz;
    v1 = (transform * vec4(v1, 1.0)).xyz;
    v2 = (transform * vec4(v2, 1.0)).xyz;

}

void main() {

    vec3 cam_origin = vec3(0.0, 0.0, 0.0);

    mat4 view_mat = view;

    vec2 raster_coord = gl_GlobalInvocationID.xy + vec2(0.5, 0.5);

    vec2 norm_coords = raster_coord / vec2(800, 800);

    vec2 screen_coord = vec2(-1.0, 1.0) + (vec2(2.0, -2.0) * norm_coords);

    vec3 screen_ray_intersection = vec3(screen_coord, -1.0);

    cam_origin = (view_mat * vec4(cam_origin, 1.0)).xyz;

    screen_ray_intersection = (view_mat * vec4(screen_ray_intersection, 1.0)).xyz;

    vec3 ray_direction = normalize(screen_ray_intersection - cam_origin);

    Ray ray = Ray(cam_origin, ray_direction);


    Light l = Light(vec3(0.0, 6.0, 3.0), 0.5);

    vec4 to_write = color;

    for(uint i=0; i<indices.length(); i= i+3){

        uint i0 = indices[i];
        uint i1 = indices[i+1];
        uint i2 = indices[i+2];

        vec3 v0 = vec3(
        vertices[3*i0 + 0],
        vertices[3*i0 + 1],
        vertices[3*i0 + 2]
        );
        vec3 v1 = vec3(
        vertices[3*i1 + 0],
        vertices[3*i1 + 1],
        vertices[3*i1 + 2]
        );
        vec3 v2 = vec3(
        vertices[3*i2 + 0],
        vertices[3*i2 + 1],
        vertices[3*i2 + 2]
        );

        model_world_transform(model, v0, v1, v2);
        float a = mollerTrumboreIntersectTriangle(ray.origin, ray.direction, v0, v1, v2);

        if (a > EPSILON) {

            vec3 intersection_point = ray.origin + ray.direction * a;

            vec3 light_direction = normalize(l.position - intersection_point);

            float light_distance = distance(l.position, intersection_point);

            vec3 edge1 = v1 - v0;
            vec3 edge2 = v2 - v0;
            vec3 surface_normal = cross(edge2, edge1);

            vec3 P = cross(light_direction, edge2);
            //P = normalize(P);
            // if determinant is near zero, ray lies in plane of triangle
            float det = dot(edge1, P);

            float shade = 0.0;

            if (det < EPSILON ) {

                shade = -1.0 * det * 15.0 * (1 / (light_distance * light_distance));
            }

            to_write = vec4(shade, shade, shade, 1.0);

        }
    }

    imageStore(img, ivec2(gl_GlobalInvocationID.xy), to_write);


}

