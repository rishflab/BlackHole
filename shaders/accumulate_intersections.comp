#version 450

#define EPSILON 0.0001

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

struct Intersection {
    vec4 position;
    vec4 normal;
    vec3 edge;
    float a;
};

struct Light {
    vec4 position;
    float intensity;
};

layout(binding = 0, rgba8) uniform image2D img;


layout(set = 1, binding = 0) uniform Lights {
    Light lights[];
};

layout(set = 1, binding = 1) buffer Resolution {
    uvec2 resolution;
};

layout(set = 1, std430, binding = 2) buffer P_Intersections {
    Intersection p_intersections[];
};

layout(set = 1, std430, binding = 3) buffer B_Intersections {
    Intersection b_intersections[];
};

void main() {

    float aspect_ratio = 1.2;

    uint samples = 4;

    uint index = gl_GlobalInvocationID.x*samples;

    uint quotient = gl_GlobalInvocationID.x/resolution.x;

    uint remainder = uint(mod(gl_GlobalInvocationID.x, resolution.x));

    uvec2 pixel = uvec2(remainder, quotient);

    Light light = lights[0];

    vec4 to_write = vec4(0.0, 0.0, 0.0, 0.0);

    vec4 sum = vec4(0.0, 0.0, 0.0, 1.0);;

    for (uint i=index; i < index+samples; i++){

        Intersection b_intersection = b_intersections[i];

        if (b_intersection.a != -1.0) {

            vec4 light_direction = normalize(light.position - b_intersection.position);

            float light_distance = distance(light.position, b_intersection.position);

            float shade = 0.0;
            float diffuse = 0.0;
            //float ambient = 0.1;

            diffuse = max(-1.0 * dot(b_intersection.normal, light_direction), 0.0);

            shade = 1.0*(1/(light_distance * light_distance))* diffuse;

            sum += vec4(shade, shade, shade, 0.0);
        }

        Intersection intersection = p_intersections[i];

        if (intersection.a != -1.0) {

            vec4 light_direction = normalize(light.position - intersection.position);

            float light_distance = distance(light.position, intersection.position);

            float shade = 0.0;
            float diffuse = 0.0;
            float ambient = 0.1;

            diffuse = max(-1.0 * dot(intersection.normal, light_direction), 0.0);

            shade = ambient + 5.0*(1/(light_distance * light_distance))* diffuse;

            sum += vec4(shade, shade, shade, 0.0);
        }
    }

    to_write =  sum/samples;

    imageStore(img, ivec2(pixel.xy), to_write);

}