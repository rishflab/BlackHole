#version 450

#define EPSILON 0.0001

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

struct Ray{
    vec4 origin;
    vec4 direction;
};

struct Intersection{
    vec4 color;
};

struct Aabb{
    vec4 min;
    vec4 max;
};

layout(std430, binding = 0) buffer restrict readonly Rays {
    Ray rays[800][800];
};

layout(binding = 1) buffer restrict readonly Indices {
    uint indices[];
};

layout(binding = 2) buffer restrict readonly VertexOut {
    vec4 vertexOut[];
};

layout(std430, binding = 3) buffer restrict writeonly Intersections {
    Intersection intersections[800][800];
};

layout(std430, binding = 4) buffer restrict readonly BoundingBox {
    Aabb aabb[];
};

struct Light {
    vec3 position;
    float intensity;
};

bool intersectTriangle(Ray ray, vec3 v1, vec3 v2, vec3 v3){
    const vec3 e1 = v2 - v1;
    const vec3 e2 = v3 - v1;
    const vec3 s1 = cross(ray.direction.xyz, e2);
    const float  invd = 1.0f/(dot(e1, s1));
    const vec3 d = ray.origin.xyz - v1;
    const float  b1 = dot(d, s1) * invd;
    const vec3 s2 = cross(d, e1);
    const float  b2 = dot(ray.direction.xyz, s2) * invd;
    const float temp = dot(e2, s2) * invd;

    if ( b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f || temp < 0.0 ){
        return false;
    } else {
        return true;
    }
}

bool IntersectBox(Ray ray, Aabb box){

    vec4 tMin = (box.min - ray.origin) / ray.direction;
    vec4 tMax = (box.max - ray.origin) / ray.direction;
    vec4 t1 = min(tMin, tMax);
    vec4 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return (tFar >= tNear) ? true : false;
}

void main(){

    Light l = Light(vec3(0.0, 6.0, 3.0), 0.5);

    uvec2 current = gl_GlobalInvocationID.xy;

    Ray ray = rays[current.x][current.y];

    //BoundingBox bbox = BoundingBox(vec4(-1.1, -1.1, -1.1, 0.0), vec4(1.1, 1.1, 1.1, 0.0));

    vec4 to_write = vec4(0.0, 0.0, 0.0, 0.0);

    if (IntersectBox(ray, aabb[0]) ==  true) {

        for (uint j = 0; j < (indices.length()/3); j++){

            uint i = 3*j;
            uint i0 = indices[i];
            uint i1 = indices[i+1];
            uint i2 = indices[i+2];

            vec3 v0 = vertexOut[i0].xyz;
            vec3 v1 = vertexOut[i1].xyz;
            vec3 v2 = vertexOut[i2].xyz;

            bool a = intersectTriangle(ray, v0, v1, v2);

            if (a == true){
                to_write = vec4(0.0, 1.0, 0.0, 1.0);
                intersections[current.x][current.y] = Intersection(to_write);
                break;
            }
            else {
                intersections[current.x][current.y] = Intersection(to_write);
            }


        }
    } else {
        intersections[current.x][current.y] = Intersection(to_write);
    }


}