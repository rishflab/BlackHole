#version 450

#define EPSILON 0.0001

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

struct Ray {
    vec4 origin;
    vec4 direction;
};

struct Intersection {
    vec4 color;
};

struct Aabb {
    vec4 min;
    vec4 max;
};

//struct MeshHandle {
//    mat4 transform;
//    uint start;
//    uint end;
//    uint instance;
//    uint size;
//};

layout(std430, binding = 0) buffer restrict readonly Rays {
    Ray rays[800][800];
};

//layout(binding = 1) buffer restrict readonly Indices {
//    uint indices[];
//};

layout(binding = 1) buffer restrict readonly Triangles {
    vec4 tris[];
};

layout(std430, binding = 2) buffer restrict writeonly Intersections {
    Intersection intersections[800][800];
};

layout(std430, binding = 3) buffer restrict readonly BoundingBox {
    Aabb aabbs[];
};

//layout(std430, binding = 5) buffer restrict readonly MeshHandle {
//    MeshHandle mesh_handles[];
//};

struct Light {
    vec3 position;
    float intensity;
};

bool intersectTriangle(Ray ray, vec3 v1, vec3 v2, vec3 v3){
    const vec3 e1 = v2 - v1;
    const vec3 e2 = v3 - v1;
    const vec3 s1 = cross(ray.direction.xyz, e2);
    const float  invd = 1.0f/(dot(e1, s1));
    const vec3 d = ray.origin.xyz - v1;
    const float  b1 = dot(d, s1) * invd;
    const vec3 s2 = cross(d, e1);
    const float  b2 = dot(ray.direction.xyz, s2) * invd;
    const float temp = dot(e2, s2) * invd;

    if ( b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f || temp < 0.0 ){
        return false;
    } else {
        return true;
    }
}

bool IntersectBox(Ray ray, Aabb box){

    vec4 tMin = (box.min - ray.origin) / ray.direction;
    vec4 tMax = (box.max - ray.origin) / ray.direction;
    vec4 t1 = min(tMin, tMax);
    vec4 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return (tFar >= tNear) ? true : false;
}

void main(){

    Light l = Light(vec3(0.0, 6.0, 3.0), 0.5);

    uvec2 current = gl_GlobalInvocationID.xy;

    Ray ray = rays[current.x][current.y];

    //BoundingBox bbox = BoundingBox(vec4(-1.1, -1.1, -1.1, 0.0), vec4(1.1, 1.1, 1.1, 0.0));

    vec4 to_write = vec4(0.0, 0.0, 0.0, 0.0);

//    for (uint k = 0; k < aabbs.length(); k++){
//
//        Aabb aabb = aabbs[k];

        //if (IntersectBox(ray, aabb) ==  true) {

            for (uint j = 0; j < tris.length(); j=j+3){

//                uint i = 3*j;
//                uint i0 = indices[j];
//                uint i1 = indices[j+1];
//                uint i2 = indices[j+2];

                vec3 v0 = tris[j].xyz;
                vec3 v1 = tris[j+1].xyz;
                vec3 v2 = tris[j+2].xyz;

                vec4 cmp = vec4(-1.0, 1.0, 1.0, 1.0);
//                (1.0, 1.0, -1.0, 1.0)
//                (-1.0, 1.0, -1.0, 1.0)

                bool a = intersectTriangle(ray, v0, v1, v2);

                if (a == true){
                    to_write = vec4(0.0, 1.0, 0.0, 1.0);
//                    if (tris.length() == 72){
//                        to_write = vec4(1.0, 0.0, 0.0, 1.0);
////                        if (tris[35] == cmp){
////                            to_write = vec4(0.0, 1.0, 0.0, 1.0);
////                        }
//                    }
                    intersections[current.x][current.y] = Intersection(to_write);
                    break;
                }
                else {
                    intersections[current.x][current.y] = Intersection(to_write);
                }
            }

            //break;

//        } else {
//            intersections[current.x][current.y] = Intersection(to_write);
//        }
//    }


}